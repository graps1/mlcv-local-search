\section{Move-Operation on Indexings}\label{sec:move-operation}

We will now define the ``move''-operation on indexings, which transforms an indexing into another indexing by changing the assigned index of a vertex. The effect this has on the induced partition is that the respective vertex is ``taken'' from its original set\footnote{i.e. the set $[v]_\idx$} and then ``put into'' some other set. This is then defined as
\begin{equation} 
\move{\idx}{ v}{ k}(u) = \begin{cases}
    \idx(u) & u \neq v, \\ 
    k & u = v
\end{cases} \label{eq:move-operation}
\end{equation} 
for every vertex $u$. The operation takes as input an indexing $\idx$, a vertex $v$ and new index $k$ and outputs a new indexing that is essentially the same as $\idx$, with the only difference being that $v$ is mapped to $k$ instead of whatever it was mapped to before.

\subsection{Move-Enumeration}

In many cases, there are multiple ways of moving one vertex to different indices while still inducing the same partition afterwards. For example, if $v$ is an arbitrary vertex, $\idx$ is an indexing of $V$ with pairwise different $k_1,k_2$ such that there is no vertex $u$ with $\idx(u) = k_1$ or $\idx(u) = k_2$, then moving $v$ to $k_1$ or $k_2$ yields that while $\move{\idx}{v}{k_1}$ and $\move{\idx}{v}{k_2}$ are different indexings, their induced partitions are the same: $\Pi(\move{\idx}{v}{k_1}) = \Pi(\move{\idx}{v}{k_2})$. Based on this observation we are interested in an efficient way of enumerating all possible ``moves'' of a vertex with respect to the induced partitions without enumerating too much or having to double-check whether two move-operations induce the same partition. Hence, consider algorithm \ref{alg:moveenum}, which aims at finding a solution to this problem.

\begin{algorithm}[H]
    \SetAlgoLined
    \DontPrintSemicolon
    \KwIn{Set of vertices $V$ with indexing $\idx$}
    \KwResult{Sequence of moves $(w_1,k_1),\dots,(w_m,k_m)$ }
    Let $<$ be some linear order on $V$ \label{alg:moveenum:l1} \;
    Let $\mathcal{N} := \{1,\dots,n\}\backslash \image(\idx)$  \label{alg:moveenum:l2} \;
    \ForAll{vertices $w \in V$}{  \label{alg:moveenum:l3}
        \ForAll{$\idx(v) \in \image(\idx) \backslash \{ \idx(w) \}$}{  \label{alg:moveenum:l4}
            \uIf{$[w]_\idx = \{ w, u, \dots \}$ or $[v]_\idx  = \{ v, s, \dots \}$}{  \label{alg:moveenum:l5}
                enumerate $(w, \idx(v))$  \label{alg:moveenum:l6} \;
            }\uElseIf{$[w]_\idx = \{ w \}$ and $[v]_\idx = \{ v \}$ and $w < v$}{ \label{alg:moveenum:l7}
                enumerate $(w, \idx(v))$  \label{alg:moveenum:l8} \;
            }
        }
        \uIf{$[w]_\idx = \{ w, u, v, \dots \}$ or $([w]_\idx = \{w,u\}$ and $w < u)$}{  \label{alg:moveenum:l9}
            Let $k \in \mathcal{N}$  \label{alg:moveenum:l10} \;
            enumerate $(w, k)$  \label{alg:moveenum:l11} \;
        }
    }
    \caption{Move-Enumeration} \label{alg:moveenum}
\end{algorithm}

The intuition is as follows. Line \ref{alg:moveenum:l1} fixes a linear order on $V$, which can be understood as a preference relation when the movement of two different vertices would yield the same partition. Line \ref{alg:moveenum:l2} defines $\mathcal{N}$ as the container for all indices that have no assigned vertices. What follows is the consideration of all possible moves of a vertex $v$ to some other index $k$ (line \ref{alg:moveenum:l3}, \ref{alg:moveenum:l4}, \ref{alg:moveenum:l9}): in line \ref{alg:moveenum:l4}, vertices are possibly moved to indices that are not empty, and in line \ref{alg:moveenum:l9}, vertices are possibly moved to empty indices\footnote{Mind that if $\mathcal{N} = \emptyset$, then there is no way line \ref{alg:moveenum:l9} will evaluate to true: since every index has some vertex that is assigned to it, and the amount of vertices is equal to the amount of indices, every vertex is ``alone'' at its index.}.\\
We want to check three important properties: one, algorithm \ref{alg:moveenum} only enumerates moves which yield pairwise distinct partitions (the ``not too much''-part), two, every possible move is equivalent to one of the enumerated moves and three, the induced partition by any enumerated move is not the same as the partition induced by $\idx$. I.e., if $\idx$ is an indexing of $V$ and $(w_1,k_1),\dots,(w_m,k_m)$ is a sequence generated by algorithm \ref{alg:moveenum} on input $V$ and $\idx$, Lemma \ref{lemma:pairwise_distinctiveness}, \ref{lemma:completeness} and \ref{lemma:self_neighbour} hold.

\begin{lemmarep}[Pairwise Distinctiveness]
    $\Pi(\move{\idx}{w_i}{k_i}) \neq \Pi(\move{\idx}{w_j}{k_j})$ for all $1 \leq i < j \leq m$. \label{lemma:pairwise_distinctiveness}
\end{lemmarep}
\begin{\appendixproof}
    Note that every pair $(w,k) \in V \times \{1,\dots,n\}$ is regarded at most once. This means that for every two different indexings $\move{\idx}{w_i}{k_i},\move{\idx}{w_j}{k_j}$, either $w_i \neq w_j$ or $k_i \neq k_j$ holds. Now, pick $i,j \in \{1,\dots,m\}$ such that $i \neq j$. The rest of the proof can be done via case distinction on all possible conditions under which a move could be enumerated in the algorithm:
    \begin{enumerate}
        \item $w_i = w_j = w$. Since $i$ and $j$ are pairwise distinct, $k_i \neq k_j$ must hold. For $k_i$, we have either $k_i \in \mathcal{N}$ (line \ref{alg:moveenum:l9}) or $k_i = \idx(v) \in \image(\idx)\backslash \{ \idx(w) \}$ (line \ref{alg:moveenum:l6} and \ref{alg:moveenum:l8}):
        \begin{enumerate}
            \item If $k_i \in \mathcal{N}$: Then $\move{\idx}{w_i}{k_i}(w) = k_i$ only for $w$ (since there is no vertex that is mapped to $k_i$ in $\idx$). Also $k_j \not\in \mathcal{N}$, since there is at maximum one $k \in \mathcal{N}$ for which $\move{\idx}{w}{k}$ is enumerated. Thus, $k_j = \idx(v) \in \image(\idx)\backslash \{ \idx(w) \}$. But then we have $\move{\idx}{w_j}{k_j}(w) = k_j =\move{\idx}{w_j}{k_j}(v)$ and $\move{\idx}{w_i}{k_i}(v) = k_j \neq k_i = \move{\idx}{w_i}{k_i}(w)$, which implies $\Pi(\move{\idx}{w_i}{k_i}) \neq \Pi(\move{\idx}{w_j}{k_j})$ by Theorem \ref{theorem:equal_indexings}.
            \item If $k_i = \idx(v) \in \image(\idx)\backslash \{\idx(w) \}$: After moving $w$ to $k_i$ in $\move{\idx}{w_i}{k_i}$, one obtains $\move{\idx}{w_i}{k_i}(w) = \move{\idx}{w_i}{k_i}(v) = k_i$, and after moving $w$ to $k_j$ in $\move{\idx}{w_j}{k_j}$, one gets $\move{\idx}{w_j}{k_j}(w) = k_j \neq k_i = \move{\idx}{w_j}{k_j}(v)$. But that implies $\Pi(\move{\idx}{w_i}{k_i}) \neq \Pi(\move{\idx}{w_j}{k_j})$ by Theorem \ref{theorem:equal_indexings}.  
        \end{enumerate}
        \item $w_i \neq w_j$, and therefore $\move{\idx}{w_i}{k_i}(w_j) = \idx(w_j)$ and $\move{\idx}{w_j}{k_j}(w_i) = \idx(w_i)$ (i.e., $\move{\idx}{w_i}{k_i}$ does not change the index of $w_j$ and $\move{\idx}{w_j}{k_j}$ does not change the index of $w_i$). Again, we make the distinction for the case $k_i \in \mathcal{N}$ and $k_i = \idx(v) \in \image(\idx)\backslash \{ \idx(w) \}$:
        \begin{enumerate}
            \item If $k_i \in \mathcal{N}$: since $k_i \not\in \image(\idx)$, $\idx(w_i) \neq k_i$. Also, at least one of the following cases (see line 9 of the algorithm) must hold:
            \begin{enumerate}
                \item If $[w_i]_\idx = \{ w_i, u, v, \dots \}$: At least one of the vertices $u$ and $v$ must be different from $w_j$, since $u \neq v$ and $w_j$ cannot be equal to both of them. Let w.l.o.g. $u \neq w_j$. Then $\move{\idx}{w_j}{k_j}(w_i) = \idx(w_i) = \idx(u) = \move{\idx}{w_j}{k_j}(u)$ but $\move{\idx}{w_i}{k_i}(w_i) = k_i \neq \idx(w_i) = \move{\idx}{w_i}{k_i}(u)$, i.e. $\Pi(\move{\idx}{w_i}{k_i}) \neq \Pi(\move{\idx}{w_j}{k_j})$ by Theorem \ref{theorem:equal_indexings}.
                \item If $[w_i]_\idx = \{w_i, u \}$ and $w_i < u$: 
                \begin{enumerate}
                    \item $w_j \neq u$: We get $\move{\idx}{w_i}{k_i}(w_i) \neq \move{\idx}{w_i}{k_i}(u)$ and $\move{\idx}{w_j}{k_j}(w_i) = \idx(w_i) = \idx(u) = \move{\idx}{w_j}{k_j}(u)$. Then simply apply Theorem \ref{theorem:equal_indexings} and obtain $\Pi(\move{\idx}{w_i}{k_i}) \neq \Pi(\move{\idx}{w_j}{k_j})$.
                    \item $w_j = u$. Since $u \not< w_i$ and $[w_j]_\idx = [w_i]_\idx$, there is no possibility that line 11 is executed for $w_j$. Therefore, $k_j \not\in \mathcal{N}$. But then $k_j= \idx(v) \in \image(\idx)\backslash \{ \idx(w_j) \}$ with $w_i \neq v \neq w_j$. Thus, $\move{\idx}{w_j}{k_j}(w_j) = \idx(v)=\move{\idx}{w_j}{k_j}(v)$ and $\move{\idx}{w_i}{k_i}(w_j) = \idx(w_j) \neq \idx(v) = \move{\idx}{w_i}{k_i}(v)$. Again, the application of Theorem \ref{theorem:equal_indexings} yields $\Pi(\move{\idx}{w_i}{k_i}) \neq \Pi(\move{\idx}{w_j}{k_j})$.
                \end{enumerate}
            \end{enumerate}
            \item If $k_i = \idx(v) \in \image(\idx)\backslash \{ \idx(w_i) \}$, then one of the following cases applies:
            \begin{enumerate}
                \item $[w_i]_\idx = \{w_i,u,\dots\}$. 
                \begin{enumerate}
                    \item If $w_j = u$: then $\move{\idx}{w_j}{k_j}(w_i) = \idx(w_i) \neq \idx(v) = \move{\idx}{w_j}{k_j}(v)$ and $\move{\idx}{w_i}{k_i}(w_i) = \idx(v) = \move{\idx}{w_i}{k_i}(v)$. Here, Theorem \ref{theorem:equal_indexings} can be applied, which results in $\Pi(\move{\idx}{w_i}{k_i}) \neq \Pi(\move{\idx}{w_j}{k_j})$.
                    \item If $w_j \neq u$: then $\move{\idx}{w_j}{k_j}(w_i) = \idx(w_i) = \idx(u) = \move{\idx}{w_j}{k_j}(u)$ and $\move{\idx}{w_i}{k_i}(w_i) \neq \idx(w_i) = \idx(u) = \move{\idx}{w_i}{k_i}(u)$. Theorem \ref{theorem:equal_indexings} can be applied with result $\Pi(\move{\idx}{w_i}{k_i}) \neq \Pi(\move{\idx}{w_j}{k_j})$.
                \end{enumerate}
                \item $[v]_{\idx} = \{v,s,\dots\}$. Let w.l.o.g. $w_j \neq s$ (otherwise, if $w_j = s$, then $w_j \neq v$ and a symmetric argument applies). Then $\move{\idx}{w_i}{k_i}(w_i) = \move{\idx}{w_i}{k_i}(s)$ but $\move{\idx}{w_j}{k_j}(w_i) = \idx(w_i) \neq  \idx(s) = \move{\idx}{w_j}{k_j}(s)$. In this case, Theorem \ref{theorem:equal_indexings} can be applied to obtain $\Pi(\move{\idx}{w_i}{k_i}) \neq \Pi(\move{\idx}{w_j}{k_j})$.
                \item $[w_i]_\idx = \{ w_i \}$ and $[v]_\idx = \{ v \}$ and $w_i < v$.
                \begin{enumerate}
                    \item If $w_j = v$. Then neither line \ref{alg:moveenum:l6} (since $|[w_j]_\idx| = 1$) nor line \ref{alg:moveenum:l8} are executed for $w_j$ and $k = \idx(w_i)$ (since $w_j \not < w_i$). Thus, $k_j \neq \idx(w_i)$ must hold. But then $\move{\idx}{w_i}{k_i}(w_i) = k_i = \idx(v) = \idx(w_j) = \move{\idx}{w_i}{k_i}(w_j)$ and $\move{\idx}{w_j}{k_j}(w_i) = \idx(w_i) \neq k_j = \move{\idx}{w_j}{k_j}(w_j)$. Application of Theorem \ref{theorem:equal_indexings} yields $\Pi(\move{\idx}{w_i}{k_i}) \neq \Pi(\move{\idx}{w_j}{k_j})$.
                    \item If $w_j \neq v$. Then $\move{\idx}{w_i}{k_i}(w_i) = \idx(v) = \move{\idx}{w_i}{k_i}(v)$ but $\move{\idx}{w_j}{k_j}(w_i) = \idx(w_i) \neq \idx(v) = \move{\idx}{w_j}{k_j}(v)$. Again, application of Theorem \ref{theorem:equal_indexings} gives us $\Pi(\move{\idx}{w_i}{k_i}) \neq \Pi(\varidx)$.
                \end{enumerate} 
            \end{enumerate}
        \end{enumerate}
    \end{enumerate}
    This finishes the proof, since in all cases $\Pi(\move{\idx}{w_i}{k_i}) \neq \Pi(\move{\idx}{w_j}{k_j})$ holds.
\end{\appendixproof}

\begin{lemmarep}[Completeness]
    For all vertices $w$ and $k \in \{1,\dots,n\}$, there is $i\in \{1,\dots,m\}$ such that $\Pi(\move{\idx}{w}{k}) = \Pi(\move{\idx}{w_i}{k_i})$ if $\Pi(\move{\idx}{v}{k}) \neq \Pi(\idx)$.\label{lemma:completeness}
\end{lemmarep}
\begin{\appendixproof}
    Let $\idx$ be an indexing of $V$, let $w$ be a vertex and $k\in\{1,\dots,n\}$. We want to show that if $\Pi(\move{\idx}{w}{k}) \neq \Pi(\idx)$, then there is an $i\in \{1,\dots,m\}$ such that $\Pi(\move{\idx}{w}{k}) = \Pi(\move{\idx}{w_i}{k_i})$. First, note that $\idx(w)\neq k$ holds, since otherwise this would imply $\Pi(\move{\idx}{w}{k}) = \Pi(\idx)$. The remainder of this proof works with multiple case distinctions:
    \begin{enumerate}
        \item If $[w]_\idx = \{ w \}$. This directly implies $k = \idx(v)$ for a $v \in V$, since otherwise that would mean $\Pi(\move{\idx}{w}{k}) = \Pi(\idx)$. Thus, for $[v]_\idx$ there are the following options:
        \begin{enumerate}
            \item If $[v]_\idx = \{ v \}$. In the case $w < v$, line \ref{alg:moveenum:l8} enumerates $\move{\idx}{w}{k}$ directly.  Otherwise, if $v < w$, line \ref{alg:moveenum:l8} enumerates $\move{\idx}{v}{\idx(w)}$, where $\Pi(\move{\idx}{v}{\idx(w)}) = \Pi(\move{\idx}{w}{k})$. 
            \item If $[v]_\idx = \{ v,s,\dots \}$. Line \ref{alg:moveenum:l6} in the algorithm directly enumerates $\move{\idx}{w}{k}$.
        \end{enumerate} 
        \item If $[w]_\idx = \{ w,u, \dots \}$. Since $\idx$ maps $w$ and $u$ to the same index, there is at least one index in $1,\dots,n$ that is assigned no vertex. But then $\mathcal{N} \neq \emptyset$. Again, there are the following options:
        \begin{enumerate}
            \item There is no $v \in V$ such that $k = \idx(v)$: 
            \begin{enumerate}
                \item If $[w]_\idx = \{ w,v,u,\dots \}$, then line \ref{alg:moveenum:l11} is executed and there is some $\ell \in \mathcal{N}$ for which $\move{\idx}{w}{\ell}$ is enumerated. But then $\Pi(\move{\idx}{w}{k})=\Pi(\move{\idx}{w}{\ell})$.
                \item If $[w]_\idx = \{w,u\}$. 
                \begin{enumerate}
                    \item If $w < u$, then line \ref{alg:moveenum:l11} enumerates $\move{\idx}{w}{\ell}$ for $w$ and some $\ell \in \mathcal{N}$. But then $\Pi(\move{\idx}{w}{\ell}) = \Pi(\move{\idx}{w}{k})$.
                    \item If $u < w$, then line \ref{alg:moveenum:l11} enumerates $\move{\idx}{u}{\ell}$ for $u$ and some $\ell \in \mathcal{N}$. But then again, $\Pi(\move{\idx}{u}{\ell}) = \Pi(\move{\idx}{w}{k})$.
                \end{enumerate} 
            \end{enumerate}
            \item There is $v \in V$ such that $k = \idx(v)$. Then $k \in \image(\idx)\backslash \{ \idx(w) \}$ and line 6 is executed. This enumerates $\move{\idx}{w}{k}$.
        \end{enumerate}
    \end{enumerate}
    This shows that in all cases, there is some $\move{\idx}{w_i}{k_i}$ that is enumerated which yields the same partition as $\move{\idx}{v}{k}$.
\end{\appendixproof}

\begin{lemma}[No self-neighbour]
    $\Pi(\idx) \neq \Pi(\move{\idx}{w_i}{k_i})$ for all $i\in \{1,\dots,m\}$. \label{lemma:self_neighbour}
\end{lemma}
\begin{proof}
    $\Pi(\move{\idx}{v}{k}) = \Pi(\idx)$ if and only if either $k=\idx(v)$ or if $[v]_\idx = \{v\}$ and $k \in \mathcal{N}$. Case distinction yields that both cases never happen for any $\move{\idx}{w_i}{k_i}$, $i\in \{1,\dots,m\}$.
\end{proof}

\subsection{Move-Enumeration with Random Order}\label{sec:random_move_order}

By inspection of algorithm \ref{alg:moveenum}, it can be seen that the overall amount of neighbours $m$ of an indexing $\idx$ is closely bounded by $|V|\cdot |\Pi(\idx)|$, since for every vertex $v$, the amount of $k$'s that are enumerated are at maximum $|\image(\idx)\backslash\{ \idx(v) \}| + 1 = |\image(\idx)|-1+1 = |\Pi(\idx)|$. Since the amount of sets in a partition is bounded by $|V|$, one obtains an amount of neighbours in the order of $O(|V|^2)$. This may be prohibitive if $|V|$ becomes larger, and we are therefore only interested in a smaller part of the neighbourhood of $\idx$, such that the resulting subset is representative for the complete neighbourhood. If the goal is to select a random neighbour from an indexing $\idx$, it should not be required to enumerate all possible neighbours (since this operation is in $O(|V|^2)$) and then having to sample from the resulting set afterwards. Thus, we want to construct a random variable $({\bf w}, {\bf k}) \sim \mathcal{U}(\{ (w_1,k_1),\dots,(w_m,k_m) \})$ where sampling is not too costly. For simplification, let $S = \{ (w_1,k_1),\dots,(w_m,k_m) \}$ be the set of neighbours of $\idx$ and define $S_w = \{ k : (v,k) \in S, w=v \}$ (i.e., $S_w$ contains exactly the $k$'s that are enumerated together with $w$ on their left side). We can then decompose $\mathcal{U}({\bf w}, {\bf k})$ into two parts
$$ \mathcal{U}({\bf w}, {\bf k}) = \mathcal{Q}({\bf w}) \mathcal{P}({\bf k}|{\bf w}), $$ where for all $(w,k) \in S$,
\begin{align*}
    \mathcal{Q}({\bf w} = w) &= \frac{| S_w |}{|S|},\\
    \mathcal{P}({\bf k} = k | {\bf w} = w) &= \frac{1}{| S_w |},
\end{align*}
i.e. $\mathcal{Q}$ models the probability of a vertex $w$ occuring on the left side of a tuple when drawing uniformly from $S$, and $\mathcal{P}$ models the probability of a $k$ occuring on the right side if $w$ is given (and since every possible $k$ occurs exactly once for a given $w$, they all have the same probability). Putting it together yields $\mathcal{U}({\bf w}=w, {\bf k}=k) = 1/|S|$ for all $(w,k) \in S$, i.e. $\mathcal{U}$ is indeed a uniform probability distribution over $S$. In order to compute $|S_w|$ for all vertices, we need to be able to count how often a vertex appears on the left side of all tuples. This can be done by looking at algorithm \ref{alg:moveenum}, and making case distinctions for $[w]_\idx$:
\begin{enumerate}
    \item $[w]_\idx = \{ w,u,v,\dots \}$. Then both line \ref{alg:moveenum:l5} and \ref{alg:moveenum:l9} apply, and $(w,\cdot)$ is enumerated for all $k \in \image(\idx)\backslash\{\idx(w)\} \cup \{ \ell \}$, where $\ell \in \mathcal{N}$. I.e., we obtain $S_w = \image(\idx)\backslash\{\idx(w)\} \cup \{ \ell \}$ with $|S_w| =|\image(\idx)|$.
    \item $[w]_\idx = \{ w,u \}$. Then line \ref{alg:moveenum:l5} can be applied and also line \ref{alg:moveenum:l9}, but only if $w < u$. This yields $S_w = \image(\idx)\backslash \{ \idx(w)\} \cup \{ \ell \}$ if $w < u$, and $S_w = \image(\idx)\backslash \{ \idx(w) \}$ if $u<w$. I.e., either $|S_w| =|\image(\idx)|$ or $|S_w| =|\image(\idx)|-1$.
    \item $[w]_\idx = \{ w \}$. Line \ref{alg:moveenum:l5} only evaluates to true if the goal index contains at least two different indices, and line \ref{alg:moveenum:l7} only applies if the other vertex is strictly greater than $w$. Line \ref{alg:moveenum:l9} never applies. Therefore, one obtains $S_w = \{ \idx(v) : v\in V, |[v]_\idx| \geq 2 \} \cup \{ \idx(v) : v\in V, [v]_\idx = \{ v \}, w < v \}$ and thus $|S_w| = |\{ \idx(v) : v\in V, |[v]_\idx| \geq 2 \}|+|\{ \idx(v) : v\in V, [v]_\idx = \{ v \}, w < v \}|$. The first summand can be computed relatively easy and is the same for all vertices, but the second might cause problems, since its computation depends on $w$. Fortunately, this can be solved: let $K = \{ \idx(v) : v\in V, [v]_\idx = \{ v \}\}$ be the set that contains indices which only have one vertex, and let $K_w = \{ \idx(v) \in K : w < v \}$ be the subset of $K$ that contains only indices of vertices which are strictly greater than $w$ (note that $K_w = \{ \idx(v) : v\in V, [v]_\idx = \{ v \}, w < v \}$). Assume for $K = \{ \idx(v_1),\dots,\idx(v_{|K|}) \}$, we can write down the order of the elements as $ v_1 < \dots < v_i < v_{i+1} < \dots < v_{|K|} $. Thus, $K_{v_i} = \{ \idx(v_{i+1}),\dots,\idx(v_{|K|})\}$ and therefore $|K_{v_i}| = |K| - i$. One can then pre-compute $|K_{v_i}|$ for every vertex $v_i$ with $[v_i]_\idx = \{v_i\}$ by iterating over the linear order for $i=1,\dots,|K|$.
\end{enumerate}
Putting it together, we obtain 
\begin{align}
    |S_w| = \begin{cases}
        |\image(\idx)| & [w]_\idx = \{ w,u,v,\dots \} \\
        |\image(\idx)| & [w]_\idx = \{w,u\} \;\text{and}\; w < u \\ 
        |\image(\idx)|-1 & [w]_\idx = \{w,u\} \;\text{and}\; u < w \\
        |\{ \idx(v) : v\in V, |[v]_\idx| \geq 2 \}| +|K_w| & [w]_\idx = \{w\}
    \end{cases} \label{eq:S_w}
\end{align}
and hence, algorithm \ref{alg:moverand}.

\begin{algorithm}[H]
    \SetAlgoLined
    \DontPrintSemicolon
    \KwIn{Set of vertices $V$ with indexing $\idx$, number of neighbours $N$}
    \KwResult{Uniformly random moves $(w_1,k_1),\dots,(w_N,k_N)$ }
    Let $<$ be a linear order on $V$ \label{alg:moverand:l1} \;
    Compute $|\image(\idx)|$ and $|\{ \idx(v) : v\in V, |[v]_\idx| \geq 2 \}|$ \label{alg:moverand:l2} \;
    Compute $K = \{ \idx(v) : v \in V, [v]_\idx = \{v\}\} = \{ \idx(v_1),\dots,\idx(v_{|K|}) \}$, $v_1 < \dots < v_{|K|} $ \label{alg:moverand:l3} \;
    For each vertex $w$, compute $|S_w|$ from formula \eqref{eq:S_w} and results from line \ref{alg:moverand:l2} and \ref{alg:moverand:l3} \label{alg:moverand:l4} \;
    Compute $|S| = \sum_{v \in V} |S_v|$ \label{alg:moverand:l5} \;
    \For{$i=1,\dots,N$}{
        Sample $w$ with probability $|S_w|/|S|$ from $V$ \label{alg:moverand:l6} \;
        Generate $S_w$ through enumeration of all possible $k$'s as in line \ref{alg:moveenum:l4} - \ref{alg:moveenum:l11} in algorithm \ref{alg:moveenum} \label{alg:moverand:l7} \;
        Sample $k$ with probability $1/|S_w|$ from $S_w$ \label{alg:moverand:l8} \;
        enumerate $(w,k)$\;
    }
    \caption{Random Move-Enumeration} \label{alg:moverand}
\end{algorithm}

As already stated, enumerating the complete neighbourhood and then sampling $N$ neighbours afterwards would be bounded by $O(|V|\cdot|\Pi(\idx)|+ N) = O(|V|^2+N)$ steps. Let us now check that the time of algorithm \ref{alg:moverand} is indeed better: lines \ref{alg:moverand:l1} to \ref{alg:moverand:l5} each take approximately $|V|$ steps, which yields a bound of $O(|V|)$. Line \ref{alg:moverand:l6} and \ref{alg:moverand:l7} take overall $|V|$ and $|\Pi(\idx)|$ steps\footnote{The execution time of line \ref{alg:moverand:l6} is linear in $|V|$ since we are sampling from a discrete probability distribution that is not uniform.}, and \ref{alg:moverand:l8} can be executed in constant time\footnote{Since we are sampling with uniform probability from $S_w$.}. Therefore, we obtain a run-time of $O(|V| + N(|V| + |\Pi(\idx)|)) = O(N\cdot |V|)$. Thus, if $N \ll |V|$, we are able to obtain a much faster way of generating neighbours for a given indexing.
